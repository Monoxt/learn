## 前言



在过去十年左右的时间，容器技术飞快变革，**Kubernetes** 项目已然成为容器技术的事实标准，重新定义了基础设施领域对应用编排与管理的种种可能。



> 过去以物理机和虚拟机为主体的开发运维环境，向以容器为核心的基础设施的转变过程，并不是一次温和的变革，而是涵盖了对网络、存储、调度、操作系统、分布式原理等各个方面的容器化理解和改造。



这使得很多新人，因为知识储备不足或者各种各样的原因，无法很好的掌握和理解容器技术栈表现出来的这些难题。



## 初出茅庐



在大概十年前，服务器端技术一直没有什么更新。曾经被人们寄予厚望的云计算技术，已经从当初的虚无缥缈的概念蜕变成了实实在在的虚拟机和账单。而相比于如日中天的 AWS 和盛极一时的 OpenStack，以 Cloud Foundry 为代表的开源 PaaS 项目， 却成为了当时云计算技术中的一股清流。



这时，Cloud Foundry 项目已经基本度过了最艰难的概念普及和用户教育阶段，吸引了包括百度、京东、华为、IBM 等一大批国内外技术厂商，开启了以开源 PaaS 为核心构建平台层服务能力的变革。



当时还名叫 dotCloud 的 Docker 公司，也是这股 PaaS 热潮中的一份子。只不过相比于 Heroku、Pivotal、Red Hat 等 PaaS 弄潮儿们，dotCloud 公司实在是太微不足道了，而它的主打产品由于跟主流的 Cloud Foundry 社区脱节，长期以来也无人问津。于是 dotCloud 公司做出了这样一个决定：开源自己的容器项目 Docker。



最初这个决定并没有人在意。



PaaS 项目当时提供了一种名叫“**应用托管**”的能力。当时因为虚拟机和云计算的普及，主流用户普遍会租一批 AWS 或者 OpenStack 的虚拟机，然后像以前管理物理服务器那样，用脚本或者手工的方式在这些机器上部署应用。



这样就必然会碰到云端虚拟机和本地环境不一致的问题。所以当时的云计算服务，比的就是谁能更好地模拟本地服务器环境，带来更好的“上云”体验。而 PaaS 开源项目的出现，就是当时解决这个问题的一个最佳方案。



像 Cloud Foundry 这样的 PaaS 项目，最核心的组件就是一套应用的打包和分发机制。 Cloud Foundry 为每种主流编程语言都定义了一种打包格式，用户把应用的可执行文件和启动脚本打进一个压缩包内，上传到云上 Cloud Foundry 的存储中。接着，Cloud Foundry 会通过调度器选择一个可以运行这个应用的虚拟机，然后通知这个机器上的 Agent 把应用压缩包下载下来启动。



由于需要在一个虚拟机上启动很多个来自不同用户的应用，Cloud Foundry 会调用操作系统的 Cgroups 和 Namespace 机制为每一个应用单独创建一个称作 “沙盒” 的隔离环境，然后在“沙盒”中启动这些应用进程。这样，就实现了把多个用户的应用互不干涉地在虚拟机里批量地、自动地运行起来的目的。而这些 Cloud Foundry 用来运行应用的隔离环境，就是所谓的“容器”。



Docker 项目，实际上跟 Cloud Foundry 的容器并没有太大不同。



然而，短短几个月，Docker 项目就迅速崛起了。它的崛起速度太快，以至于 Cloud Foundry 以及所有的 PaaS 社区还没来得及成为它的竞争对手，就直接被宣告出局了。



Docker 项目确实与 Cloud Foundry 的容器在大部分功能和实现原理上都是一样的，可偏偏就是这剩下的一小部分不一样的功能，成了 Docker 项目接下来“呼风唤雨”的不二法宝。



**这个功能，就是 Docker 镜像。**



PaaS 常被人诟病的一点就是打包功能。一方面用户要为每种语言、每种框架、甚至每个版本的应用维护一个打好的包，另一方面，在本地运行得很好的应用，却需要做很多修改和配置工作才能在 PaaS 里运行起来，而这些修改和配置，并没有什么经验可借鉴，基本上靠不断的试错和运气。



Docker 镜像解决的，恰恰就是打包这个根本性的问题。所谓的 Docker 镜像，其实就是一个压缩包。但是这个压缩包的内容，比 PaaS 的应用可执行文件 + 启动脚本的组合要丰富很多。实际上，大多数 Docker 镜像是直接由一个完整的操作系统的所有文件和目录构成的，所以这个压缩包里的内容跟你本地开发和测试环境用的操作系统是完全一样的。



更有意思的是，这个压缩包包含了完整的操作系统文件和目录，即包含了这个应用运行所需要的所有依赖，所以可以先用这个压缩包在本地进行开发和测试，完成之后，再把这个压缩包上传到云端运行。



> 本地环境和云端环境的高度一致。—— Docker 镜像的精髓



## 崭露头角



随着 PaaS 概念的逐步普及，以 Cloud Foundry 为代表的经典 PaaS 项目，开始进入基础设施领域的视野，平台化和 PaaS 化成了这个生态中的一个最为重要的进化趋势。但不论是 Cloud Foundry、OpenShift，还是 Clodify，**对于如何给应用打包**这个问题都没能给出一个完美的答案。



这时候一个并不引人瞩目的 PaaS 创业公司 dotCloud，却选择了开源自家的一个容器项目 Docker，而就是这样一个普通到不能再普通的技术，却开启了一个名为 ”Docker“ 的全新时代。



> 坚持把”开发者“群体放在至高无上的位置。



相比于其他企业级应用的经典 PaaS 项目们，Docker 项目的推广策略从一开始就呈现出一副”憨态可掬“的亲人姿态，把每一位后端技术人员（而不是他们的老板）作为主要的传播对象。



随着 Docker 项目的不断发力，dotCloud 公司也突然宣布将公司名称改为 ”Docker“。在2014年，Docker 公司发布 **Swarm** 项目，致力于**让开发者把应用部署在我的项目上**。



## 群雄并起



Dokcer 公司的野心也在于平台化。而在 Docker 公司决定让 Docker 项目提供更多的平台层能力之后，Core OS、RetHat 等之前合作的公司都因为不满而终止了合作。



Swarm 项目因为使用方式简单明了，且对熟悉 Docker 的开发者来说几乎没有学习成本而受到开发者们的追捧。随后，Docker 公司又收购了 Fig 项目（首次提出容器编排概念），并将其改名为 Compose，一时之间，整个 Docker 生态不断的繁荣发展起来。



后来，Mesosphere 公司发布了一个名为 Marathon 的项目，很快成为了 Docker Swarm 的一个有力竞争对手。



2014 年 6 月，基础设施领域 Google 公司突然发力，正式宣告了一个名叫 **Kubernetes** 项目的诞生。而这个项目，不仅挽救了当时的 CoreOS 和 RedHat，还如同当年 Docker 项目的横空出世一样，再一次改变了整个容器市场的格局。



## 尘埃落定



Docker 公司的商业化战略，让很多从业者明白，Docker 项目已经成为 Docker 公司的一个商业产品。而 Docker 公司在 Docker 开源项目的发展上一直保持着绝对的权威和发言权，也让很多人表示不满。



很快，Docker 公司拒绝了微软的天价收购，也拒绝了 Google 表达出的合作愿望。



于是，Google、RedHat 等开源基础设施领域玩家们，共同牵头发起了一个名为 CNCF (Cloud Native Computing Foundation) 的基金会。



目的有两个：

1. Kubernetes 项目必须能够在容器编排领域取得足够大的竞争优势
2. CNCF 社区必须以 Kubernetes 项目为核心，覆盖足够多的场景



很快，Kubernetes 项目在 GitHub 上的各项指标开始一骑绝尘，将 Swarm 项目远远地甩在了身后。







