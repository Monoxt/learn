## Vite 解决的问题

ES6 之前，传统的 JavaScript 并没有提供原生机制供开发者以模块化的方式进行开发，所以我们需要很多工具来帮忙“打包”，帮助我们将处理过后的源代码串联成可以在浏览器中运行的文件。

但随着项目体积的增加，需要处理的 JavaScript 代码量也呈指数级增长，通常需要很长时间（几分钟）才能启动开发服务器，即使使用热模块替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来，如此循环往复，就会极大地影响开发者的开发效率和幸福感。

Vite 旨在利用生态系统中的新进展解决上述问题：**浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写**。



## Vite 的不同

传统的开发服务器是基于打包器的方式，在启动时会优先抓取并构建整个应用，然后才能提供服务。

Vite 会将应用中的模块区分为 **依赖** 和 **源码** 两类：

- 依赖：大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（像组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。

  Vite 使用 **esbuild 预构建依赖**。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。

- 源码：通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载。

  最重要的是，Vite 以原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码，即只在当前屏幕上实际使用时才会被处理。



## 生产环境仍然需要打包

尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。

Vite 自带了一套构建优化和构建命令，开箱即用。



## 浏览器支持

Vite 默认的构建目标是能支持 原生 ESM 语法的 script 标签、原生 ESM 动态导入和 import.meta 的浏览器。传统浏览器需要通过官方插件 @vitejs/plugin-legacy 支持。

