## 位与运算符

位于运算符是一个二元的位运算符，即有两个操作数，表示为 `x & y`。

位与运算符会对操作数的每一位按照如下表格进行运算，对于每一位只有 0 或 1 两种情况，所以组合出来总共 `2^2 = 4`。

| 左操作数 | 右操作数 | 结果 |
| -------- | -------- | ---- |
| 0        | 0        | 0    |
| 0        | 1        | 0    |
| 1        | 0        | 0    |
| 1        | 1        | 1    |

即：

1. 无论是 0 或 1，只要位于上 1，就还是它本身
2. 无论是 0 或 1，只要位于上 0，就变成 0

```c
#include<stdio.h>

int main() {
    int a = 0b1010;
    int b = 0b0110;
    printf("%d\n", (a & b)); // 2
}
```

## 位与运算符的应用

### 奇偶性判定

对于奇偶数的判定，可以通过取模 % 来实现：

```c
#include<stdio.h>
int main() {
    if (5 % 2 == 1) {
        printf("5 是奇数\n");
    }
    if (6 % 2 == 0) {
        printf("6 是偶数\n");
    }
    return 0;
}
```

但是也可以这样写：

```c
#include<stdio.h>

 int main() {
     if (5 & 1) {
         printf("5 是奇数\n");
     }
     if ((6 & 1) == 0) {
         printf("6")
     }
 }
```

因为简单思考一下，就会明白：

| 奇/偶 | 二进制末尾 |
| ----- | ---------- |
| 奇数  | 1          |
| 偶数  | 0          |

### 取末五位

> 【例题 1】给定一个数，求它的二进制表示的末五位，以十进制输出即可。

直接求解的话，只需要将给定数不断除以 2 获取余数就可以了。

但如果用位运算的话，只需要将给定的位数与上 `0b11111`，这样一来就直接得到末五位的值了。

```c
#include<stdio.h>

int main() {
    int x;
    scanf("%d", &x);
    printf("%d\n", (x & 0b11111));
    return 0;
}
```

> 【例题 2】如果想要得到末七位、末九位、末十四位、末 K 位，应该如何实现？

```c
#include<stdio.h>

int main() {
    int x, k;
    scanf("%d %d", &x, &k);
    int b = 1;
    int i = 0;
    for (i = 0; i < k; i++) {
        b = b << 1;
        b = b + 1;
    }
    printf("%d\n", (x & b));
    return 0;
}
```

### 消除末尾五位

> 【例题 3】给定一个 32 位整数，要求消除它的末五位。

```c
#include<stdio.h>

int main() {
    int x;
    scanf("%d", &x);
    printf("%d\n", (x & 0xffffffe0));
    return 0;
}
```

### 消除末尾连续 1

> 【例题 4】给出一个整数，现在要求将这个整数转换成二进制以后，将末尾连续的 1 都变成 0，输出改变后的数（以十进制输出即可）。

乍一看好像不是很好做，但先思考一下什么是 **末尾连续 1** ？

首先，这个数的最后一位必然是 1，因为只有最后一位开始才能称得上是末尾，其次它的倒数第二位也需要是 1，才能称得上是末尾连续 1。当然，我们也可以认为只有最后一位是 1 的数也是特殊情况下的末尾连续 1。

然后是什么时候不连续呢？必然是从末尾开始，逐个往前发现的第一个不为 1 的位，这个位必然为 0，那么在这个 0 之后的所有位，就都是所谓的 **末尾连续 1**。

由上述分析可知，我们其实需要关注的数字是类似 `0111` 这样的结构。

对于 `0111` 这样的数，如果我们这样操作：

- 加一，得到 `1000`
- 将 `1000` 跟 `0111` 互与，得到 `0000`

有没有惊喜的发现，我们已经实现了题目的要求。

```typescript
function fun(n: number) {
    const m = n + 1;
    return n & m;
}
```



### 2 的幂判定

> 【例题 5】请用一句话，判断一个正数是不是 2 的幂。

简单思考一下：

- 如果一个数是 2 的幂，那么必然是如下形式：

  $\underbrace{100\dots00}_k$

- 这个数的十进制表示为 $2^{k-1}$

- 将它减一，可以得到如下的形式：

  $\underbrace{011\dots11}_k$

- 可以观察到，将两个数相与，结果为 0

- 可以简单证明一下：

  如果 $100\dots00$ 内部不全为 0，即存在 $100\dots1\dots00$ 一个 1 位于其中，则当这个数减一的时候，首位的 1 必然不会改变，即减一后的形式为: $100\dots01\dots00$ ，这样两个数相与后必然不为 0。

  由上可得，如果一个数与这个数减一相与后的结果为 0，则这个数必然是 2 的幂。

  即：

```c
(x & (x - 1)) == 0
```



































