## 概述

### 简述

- 计算机中数据的存储和传输的最小单位是字节 (byte)，一个 ASCII 码占用 1 个字节，每个字节为 8 个比特位
- 进程间通信传输字节流的过程中，为了节省带宽，往往会对传输的数据进行压缩
- 压缩算法有很多，这里介绍一种比较好理解的贪心算法——霍夫曼编码
- 霍夫曼编码的本质就是对每个出现过的 ASCII 字符，通过一个压缩字典，映射成另一个字符，映射后的字符就是二进制比特串：001、0101、00 等等
- 解压缩就是这个过程的逆过程

### 引例

#### 源字节流

对一个字符串 "HelloWorld"，默认的 ASCII 编码占用 10 个字节数，即 $10 \times 8 = 80$ 个比特位

#### 压缩字典

通过霍夫曼算法生成压缩字典如下：

| 字符 | 压缩前编码（ASCII） | 压缩后编码 |
| ---- | ------------------- | ---------- |
| d    | 01100100            | 001        |
| e    | 01100101            | 010        |
| l    | 01101100            | 10         |
| o    | 01101111            | 111        |
| r    | 01110010            | 011        |
| H    | 01001000            | 1101       |
| W    | 01010111            | 000        |

#### 编码

遍历源字节流，将对应的字符进行编码替换，得到：

| H    | e    | l    | l    | o    | w    | o    | r    | l    | d    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1101 | 010  | 10   | 10   | 111  | 000  | 111  | 011  | 10   | 001  |

#### 规范化

最后将比特流再转换为字节流，由于编码后比特流长度不一定是 8 的倍数，所以最后的 XXXX 是补足位：

| 第 1 字节 | 第 2 字节 | 第 3 字节 | 第 4 字节 |
| --------- | --------- | --------- | --------- |
| 11010101  | 01011100  | 01110111  | 0001XXXX  |

观察一下会发现，每个压缩后的编码长度都是小于 8 的，所以压缩后的总位数一定是会小于压缩前的；压缩前 80 个比特位，压缩后 32 个比特位，压缩率位 40%

#### 解码

解码过程是霍夫曼树的路径查找过程，了解霍夫曼树的构造过程，这个解码过程就一目了然。

## 概念

### 变长编码

每个 ASCII 字符占用字节数都为 1，所以它是一种定长编码；区别于定长编码，霍夫曼编码是一种变长编码，即每个 ASCII 码进行编码映射后的二进制比特串的长度不相等；它是根据字符出现的概率来构造平均长度最短的编码。换言之，如果一个字符在文档中出现的次数多，那么它的映射后的二进制比特串就应该相对较短；反之，如果出现的次数少，那么它的映射后的二进制比特串就应该相对较长。

### 前缀编码

- 前缀编码的含义是：编码集合中，任意两个编码 A 和 B，A 不能是 B 的前缀
- 这是为了保证在传输过程中，不用增加分隔符来区分两个编码值
- 霍夫曼编码是一种前缀编码，为什么呢？下文继续讲

### 比特串

简单认为就是数组，数组的最小单位就是二进制比特位，也就是只有两种值：0 或 1

### 压缩率

- 压缩率 = 压缩后字节数 / 压缩前字节数
- 压缩率的值越小越好
- 压缩率取决于字符集合，字符集合越大，压缩率越大（压缩率越小越好），256 个字符都有的话，等于不压缩，因为基本所有的编码后的字符长度都是 8 和原字符一致，甚至有可能更高；
- 如果压缩字符里面存在中文，不适合采用 霍夫曼压缩 （还是基于字符集合，中文会占用负数的 ASCII 码）；
- 了解算法以后再来看压缩率，会更加直观
- 如果所有字符都平均分布，则字符个数和压缩率的实测结果如下

| 字符个数 | 压缩率（越低越好） |
| -------- | ------------------ |
| 1        | 12.5%              |
| 2        | 18.77%             |
| 4        | 28.14%             |
| 8        | 39.08%             |
| 16       | 50.80%             |
| 32       | 62.91%             |
| 64       | 75.21%             |
| 128      | 87.61%             |
| 256      | 100%               |

## 算法详解

### 要求

1. 编码后的码值是二进制的比特串
2. 编码后的任意两个比特串 A 和 B，A 不能是 B 的前缀，这是为了保证在传输过程中，不用增加分隔符来区分两个编码值
3. 出现频率较高的字符，编码后的比特串相对较短；出现频率低的字符，编码后的比特串相对较长
4. 编码完要保证编码总长度最小

### 简述

1. 统计字节流中出现的字符次数（频率）；
2. 按照字符频率放入一个小顶优先队列中（小顶堆）
3. 如果优先队列中只剩一个结点，则这个结点为霍夫曼树的根节点；否则，取出频率最小的和次小的两个进行合并，产生一个新的结点再塞回优先队列中；其中，这个新的结点的左右子树分别是频率最小的和次小的那两个结点，新的结点的频率值为两个子树频率值的和
4. 重复 3 的过程，构造出来的树就是霍夫曼树

压缩前的串：

```c
"HelloWorld"
```

频次统计

| 字符 | 压缩前编码 | 出现频次 |
| ---- | ---------- | -------- |
| d    | 01100100   | 1        |
| e    | 01100101   | 1        |
| l    | 01101100   | 3        |
| o    | 01101111   | 2        |
| r    | 011110010  | 1        |
| H    | 01001000   | 1        |
| W    | 01010111   | 1        |

构造过程

```
    graph TB;
    10 --0--> 4
    10 --1--> 6
    6 --0--> l
    4 --0--> N1(2)
    N1(2) --0--> W
    N1(2) --1--> d
    4 --1--> N2(2)
    N2(2) --0--> e
    N2(2) --1--> r
    6 --1--> 3
    3 --0--> N3(1)
    N3(1) --0--> ......
    N3(1) --1--> H
    3 --1--> o
   
```

1. 叶子节点为每个未编码的 ASCII 字符，非叶子节点上的数字代表的是该结点为根的子树下所有字符的频率和
2. 树上任意一个非叶子节点一定有左右两颗树
3. 左子树的边权为 0，右子树的边权为 1
4. 根节点到叶子节点路径上的边权集合就是对应字符编码后的比特串，比如字符 r 编码后的比特串为 011
5. 图中 $\dots\dots$ 代表其他字符（总共 256 个字符集合），因为其他字符没有出现，所以频率都为 0

霍夫曼编码

根节点到叶子节点树边上的路径，就是对应字符的编码值

| 字符 | 压缩前编码（ASCII） | 出现频次 | 压缩后编码 |
| ---- | ------------------- | -------- | ---------- |
| d    | 01100100            | 1        | 001        |
| e    | 01100101            | 1        | 010        |
| l    | 01101100            | 3        | 10         |
| o    | 01101111            | 2        | 111        |
| r    | 01110010            | 1        | 011        |
| H    | 01001000            | 1        | 1101       |
| W    | 01010111            | 1        | 000        |

霍夫曼压缩

就是根绝编码的映射关系将每个字符替换为二进制比特串

| H    | e    | l    | l    | o    | W    | o    | r    | l    | d    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1101 | 010  | 10   | 10   | 111  | 000  | 111  | 011  | 10   | 001  |

| 第 1 字节 | 第 2 字节 | 第 3 字节 | 第 4 字节 |
| --------- | --------- | --------- | --------- |
| 11010101  | 01011100  | 01110111  | 0001XXXX  |

不可达字符

- XXXX 必定是不会出现在压缩后编码集合中的字符。仔细想一下，编码集合 256 个字符，霍夫曼树中的深度最深的那个叶子结点，它的编码长度一定超过 8 （为什么？），所以只要取这个比特串的高 8 位作为不可达字符就可以了
- 因为 前缀编码，只要是一个字符的前缀编码，必定不在编码集合中，它的前缀可以放心用来作为 不可达字符

霍夫曼解压缩

就是遍历霍夫曼树获取叶子节点了



























