# 算法的时间复杂度

> 流水不腐，户枢不蠹

思考和总结，应该是一种生活方式。

## 穷举法

### 单层循环

遍历所有的情况。

> 【例题 1】给定 n(n≤1000) 个元素 $a_i$  ，求其中 **奇数** 有多少个。

```c
int countOdd(int n, int a[]) {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (a[i] == 0) continue;
        if (a[i] & 1) cnt++;
    }
    return cnt;
}
```

### 双层循环

> 【例题 2】给定 n(n $\le$ 1000) 个元素 $a_i$，求有多少个二元组(i, j)，满足 $a_i$ + $a_j$ 是奇数( i < j )。

```c
int countOddPair (int n, int a[]) {
    int cnt = 0;
    for (i = 0; i < n; i++) {
        for (j = i + 1; j < n; j++) {
            if (a[i] + a[j] == 0) continue;
            if ((a[i] + a[j]) & 1) cnt++;
        }
    }
    return cnt;
}
```

### 三层循环

> 【例题 3】给定 n(n $\le$ 1000) 个元素 $a_i$，求有多少个三元组(i, j, k)，满足 $a_i + a_j + a_k$ 是奇数（i < j < k)。

```c
int countOddTriple (int n, int a[]) {
    int cnt = 0;
    for (i = 0; i < n; i++) {
        for (j = i + 1; j < n; j++) {
            for (k = j + 1; k < n; k++) {
                if (a[i] + a[j] + a[k] == 0) continue;
                if ((a[i] + a[j] + a[k]) & 1) cnt++; 
            }
        }
    }
    return cnt;
}
```

### 递归枚举

> 【例题 4】给定 n(n $\leq$ 1000) 个元素 $a_i$ 和一个整数 k(k $\leq$ n)，求有多少个有序 k 元组，满足它们的和是偶数。

```c
int dfs(int n, int a[], int start, int k, int sum) {
    if (k == 0) {
        return (sum & 1) ? 0 : 1;
    }
    int s = 0;
    for (i = start; i < n; i++) {
        s += dfs(n, a, i + 1, k - 1, sum + a[i])
    }
    return s;
}
```

简单解释一下：

- `dfs(int n, int a[], int start, int k, int sum)` 这个函数的含义是：给定 n 个元素的数组 a[]，从下标 start 开始，选择 k 个元素，得到的和为 sum 的情况下的符合题目要求的方案数。k = 0 时代表递归的出口
-  当选中了第 i 个元素后，剩下就是从 i + 1 （因为是有序的）个元素开始选择剩余 k - 1 个元素，很明显跟上述操作是相同的，所以递归处理就可以

思考方式：

1. 可以发现，有序 k 元组有多少个偶数跟有序 k - 1 元组有多少个偶数之间似乎没有什么关系，即本项跟上一项之间关系不大，所以不太适合找与上一项之间的规律来解决问题

2. 但是思考求解的过程会发现，对于所谓的 k 元组，其元素是一个个选出来的，假如第一个选 $a_0$ ，那么第二个就只能选比 $a_0$ 顺序靠后的数字（因为是有序元组），而对于 k - 1 元组无非也是这样，操作都是一样的。于是就会发现：

   $Sum(i, k) = a_i + Sum(i+1, k-1)(0 \leq i \leq n)(n \leq 1000)$

   即从数组 a[] 中第 i 项开始选择 k 个元素的和就等于**数组第 i 项 $a_i$** 加上从**数组 a[] 中第 i + 1 项开始选择 k - 1 个元素的和**的和。

   这就是一个典型的递归表达了，又因为对于每次递归中 $a_i$ 的选择都有 $n - i$ 个可能，所以用了一个循环来处理每一种可能，而循环中的每种可能又需要通过递归来计算前 $k - 1$ 个元素的结果。

## 时间复杂度

### 时间复杂度的表示法

在进行算法分析时，语句总的执行次数 $T(n)$ 是关于问题规模 $n$ 的函数，进而分析 $T(n)$ 随着 $n$ 的变化情况而确定 $T(n)$ 的数量级。

算法的时间复杂度，就是算法的时间度量，记作：$T(n) = O(f(n))$ 用大写的 $O$ 来体现算法时间复杂度的记法，称之为大 $O$ 记法。

#### 时间函数

> 时间复杂度往往会联系到一个函数，**自变量** 表示规模，**应变量** 表示执行时间。

- 这里所说的执行时间，是指广义的时间，单位不一定是“秒”、”毫秒“这些单位，它代表一个”执行次数“的概念，用 $f(n)$ 来表示这个时间函数。

#### 经典函数举例

![image-20230131152715903](C:\Users\monoa\AppData\Roaming\Typora\typora-user-images\image-20230131152715903.png)



【例题 1】中单层循环中随着 $n$ 的增大，执行时间就会增加，是简单的线性时间函数 $f(n) = n$。

![image-20230131152746363](C:\Users\monoa\AppData\Roaming\Typora\typora-user-images\image-20230131152746363.png)

【例题 2】中双层循环实际上是个共有 $n$ 项等差数组，$1 + 2 + ... + n - 2 + n - 1$，所以其时间复杂度为：$f(n) = \frac{n(n - 1)}{2} $

这是一个平方级别的函数。

![image-20230131153713261](C:\Users\monoa\AppData\Roaming\Typora\typora-user-images\image-20230131153713261.png)

【例题 3】中是三层循环，时间复杂度为：$f(n) = \frac{n(n-1)(n-2)}{6}$

这是一个立方级别的时间函数。

#### 时间复杂度

- 一个算法中语句的执行次数称为语句频度或时间频度。记为 $T(n)$。
- 有一种更优雅的表示法：$T(n) = O(f(n))$，其中 $O$ 念作“大 $O$”；
  - 当 $f(n) = n$，我们称这个算法拥有线性时间复杂度，记作 $O(n)$；
  - 当 $f(n) = \frac{n(n-1)}{2}$，我们称这个算法拥有平方级时间复杂度，记作 $O(n^2)$；
  - 当 $f(n) = \frac{n(n-1)(n-2)}{6}$，我们称这个算法拥有立方级的时间复杂度，记作 $O(n^3)$;
- $f$ 的函数可能很复杂，但是 $O$ 表示的函数往往比较简单，舍弃了一些无关大雅的“细节”，这是为什么呢？

#### 高阶无穷小

- 有这样一个定义：如果 $\lim\frac{\beta}{\alpha} = 0$，则称 $\beta$ 是比 $\alpha$ 高阶的无穷小。

类似的，因为相对于 $n^2$ 来说，$n$ 可以忽略不记，且系数 $\frac{1}{2}$ 不影响我们关注的问题，即也可以去掉，所以它的时间复杂度就是 $O(n^2)$ 了。

## 常见的时间复杂度

### 常数阶

```c
const int MAX = 1024;
int getMAX() {
    return MAX;
}
```

时间复杂度：$O(1)$

### 对数阶

> 【例题 4】给定 $n(n\leq100000)$ 个元素的有序数组 $a_i$ 和整数 $v$，求 $v$ 在数组中的下标，不存在输出 $-1$。

- 通常查询的时间复杂度为 $O(n)$。
- 考虑到有序的条件，可以用二分查找来优化实现。

```c
int bin(int n, int a[], int v) {
    int l = 0, r = n - 1;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (a[mid] == v) return mid;
        else if (a[mid] < v) r = mid + 1;
        else l = mid + 1;
    }
    return -1;
}
```

- 这是一个二分查找的实现，时间复杂度为 $\O(log_2n)$。

- 每次相当于把 $n$ 切半，即：

  $n \rightarrow \frac{n}{2} \rightarrow \frac{n}{4} \rightarrow ... \rightarrow \frac{n}{2^k} \rightarrow ... \rightarrow 0$

- 这条路径的长度也就是执行次数，我们需要计算最长路径（最长耗时），也就是要求 $2^k \leq n$ 中的 $k$ 的最大值，两边取以 2 为底的对数，得到：

  $k \leq \log_2n$

- 所以 $T(n) = O(f(n)) = O(k) = O(\log_2n)$

### 根号阶

> 【例题 5】给定一个数 $n(n \leq 10^9)$，问 $n$ 是否是一个素数（素数的概念，就是除了 1 和它本身，没有其他因子的数）。

- 按照素数的概念，只需要枚举所有 $i \in [2, n)$，看是否能整除 $n$，一旦能整除，代表找到了一个因子，则不是素数，当所有数枚举完还没有找到，它就是素数。

- 但这样做很明显效率太低，所以需要进一步思考

- 如果一个数有除了 1 和它本身以外的其他因子，假设为 $s$，那么它必然有另一个因子 $\frac{n}{s}$。

  假如 $s \leq \frac{n}{s}$，则可以得到 $s \leq \sqrt{n}$，如果 $s \geq \frac{n}{s}$，那么就把 $\frac{n}{s}$ 当 $s$，把 $s$ 当 $\frac{n}{s}$ 就行（本质上没区别）。

  所以只需要枚举 $\sqrt{n}$ 内的数就可以了。

```c
bool isPrime(int n) {
    int i;
    if(n == 1) {
        return false;
    }
    int sqrtn = sqrt(n + 0.0);
    for(int i = 2; i <= sqrtn; ++i) {
        if(n % i == 0) {
            return false;
        }
    }
    return true;
}
```

### 线性阶

见【例题 1】。

### 线性对数阶

> 【例题 6】 给定 $n(n \leq 100000)$ 个元素 $a_i$，求满足 $a_i + a_j = 1024$ 的有序二元组 $(i, j)$ 有多少对。

- 如果根据【例题 2】，时间复杂度为 $O(n^2)$。但是这个问题中 $n$ 的范围比较大，所以 $O(n^2)$ 的时间复杂度不太满足需求

- 其实仿照【例题 4】和【例题 5】的思路，我们可以这样来做：

  先对所有元素 $a_i$ 按照递增顺序排序，然后枚举 $a_i$，并在 $[i+1, n)$ 的范围内寻找是否存在 $a_j = 1024 - a_i$，存在则计数器 +1，而这个查找的过程可以采用二分枚举。所以时间复杂度为 $O(n\log_2n)$。

```typescript
function fun(arr: number[]) {
    const a = arr.sort((a, b) => a - b);
    const len = a.length;
    let count = 0;
    for (let i = 0; i < len; i++) {
        let l = i + 1;
        let r = len;
        let j = (l + r) >> 1;
        while (j && j <= n) {
            if (a[j] + a[i] > 1024) j = (l + j - 1) >> 1;
            if (a[j] + a[i] < 1024) j = (j + 1 + r) >> 1;
            if (a[j] + a[i] === 1024) count++;
        }
    }
    return count;
}
```

### 指数阶

> 【例题 7】给出 $n(n \leq 15)$ 个点，以及每两个点之间的关系（连通还是不连通），求一个最大集合，使得在这个集合中都连通。

- 这是求子集的问题，由于最多只有 15 个点，我们就可以枚举每个点选或者不选，总共有 $2^n$ 种情况，然后再判断是否满足题目中的连通性，时间复杂度为 $O(n^22^n)$。
- 是否有更好的算法？

### 阶乘阶

> 【例题 8】给定 $n(n \leq 12)$ 个点，并且给出任意两点间的距离，求从 $s$ 点开始经过所有点回到 $s$ 的距离的最小值。

- 同样是暴力求解，把所有点当成是一个排列，排列方案数为 $n!$
- 时间复杂度：$O(n!)$
- 更好的算法？

























